{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/steganography.ts"],"sourcesContent":["import { Jimp } from \"jimp\";\n\n// Magic header to identify our watermarked images\nconst MAGIC_HEADER = \"RECLAIM_V1:\";\n\n// End marker to know where the message ends\nconst END_MARKER = \":END_RECLAIM\";\n\nexport interface SteganographyPayload {\n  v: number; // version\n  c: string; // creator_id\n  t: number; // timestamp\n  h: string; // first 8 chars of SHA-256 of original image\n}\n\n/**\n * Convert a string to binary representation\n */\nfunction stringToBinary(str: string): string {\n  return str\n    .split(\"\")\n    .map((char) => char.charCodeAt(0).toString(2).padStart(8, \"0\"))\n    .join(\"\");\n}\n\n/**\n * Convert binary representation back to string\n */\nfunction binaryToString(binary: string): string {\n  const bytes = binary.match(/.{8}/g);\n  if (!bytes) return \"\";\n  return bytes.map((byte) => String.fromCharCode(parseInt(byte, 2))).join(\"\");\n}\n\n/**\n * Convert integer color to RGBA components\n */\nfunction intToRGBA(color: number): { r: number; g: number; b: number; a: number } {\n  return {\n    r: (color >> 24) & 0xff,\n    g: (color >> 16) & 0xff,\n    b: (color >> 8) & 0xff,\n    a: color & 0xff,\n  };\n}\n\n/**\n * Convert RGBA components to integer color\n */\nfunction rgbaToInt(r: number, g: number, b: number, a: number): number {\n  return ((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (a & 0xff);\n}\n\n/**\n * Calculate the maximum message length that can be embedded in an image\n * We use 2 bits per pixel (from the blue and green channels) for better capacity\n */\nfunction getMaxMessageLength(width: number, height: number): number {\n  // Each pixel can hold 2 bits (blue and green LSB)\n  // 8 bits per character\n  const totalBits = width * height * 2;\n  return Math.floor(totalBits / 8);\n}\n\n/**\n * Embed a payload into an image using LSB steganography\n * @param imageBuffer - The original image buffer\n * @param payload - The payload to embed\n * @returns The watermarked image as a PNG buffer\n */\nexport async function embedPayload(\n  imageBuffer: Buffer,\n  payload: SteganographyPayload\n): Promise<Buffer> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Create the full message with magic header and end marker\n  const payloadJson = JSON.stringify(payload);\n  const fullMessage = MAGIC_HEADER + payloadJson + END_MARKER;\n\n  // Check if the message fits\n  const maxLength = getMaxMessageLength(width, height);\n  if (fullMessage.length > maxLength) {\n    throw new Error(\n      `Message too long for image. Max: ${maxLength} chars, Message: ${fullMessage.length} chars`\n    );\n  }\n\n  // Convert message to binary\n  const binaryMessage = stringToBinary(fullMessage);\n\n  // Embed the binary message into the image\n  let bitIndex = 0;\n\n  for (let y = 0; y < height && bitIndex < binaryMessage.length; y++) {\n    for (let x = 0; x < width && bitIndex < binaryMessage.length; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Embed in blue channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.b = (rgba.b & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Embed in green channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.g = (rgba.g & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Set the modified pixel\n      const newColor = rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a);\n      image.setPixelColor(newColor, x, y);\n    }\n  }\n\n  // Return as PNG buffer (PNG is lossless, important for LSB)\n  return await image.getBuffer(\"image/png\");\n}\n\n/**\n * Extract a payload from an image\n * @param imageBuffer - The image buffer to extract from\n * @returns The extracted payload, or null if not found\n */\nexport async function extractPayload(\n  imageBuffer: Buffer\n): Promise<SteganographyPayload | null> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Extract bits from the image\n  let binaryString = \"\";\n  const maxBits = width * height * 2;\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Extract from blue channel LSB\n      binaryString += (rgba.b & 1).toString();\n\n      // Extract from green channel LSB\n      binaryString += (rgba.g & 1).toString();\n\n      // Check periodically for the end marker to avoid processing entire image\n      if (binaryString.length % 800 === 0 && binaryString.length > 0) {\n        const partialMessage = binaryToString(binaryString);\n        if (partialMessage.includes(END_MARKER)) {\n          break;\n        }\n      }\n\n      // Safety limit\n      if (binaryString.length > maxBits) break;\n    }\n\n    // Check if we've found the end marker\n    const partialMessage = binaryToString(binaryString);\n    if (partialMessage.includes(END_MARKER)) {\n      break;\n    }\n  }\n\n  // Convert binary to string\n  const extractedMessage = binaryToString(binaryString);\n\n  // Check for magic header\n  if (!extractedMessage.startsWith(MAGIC_HEADER)) {\n    return null;\n  }\n\n  // Find the end marker\n  const endIndex = extractedMessage.indexOf(END_MARKER);\n  if (endIndex === -1) {\n    return null;\n  }\n\n  // Extract the JSON payload\n  const jsonStart = MAGIC_HEADER.length;\n  const jsonString = extractedMessage.substring(jsonStart, endIndex);\n\n  try {\n    const payload = JSON.parse(jsonString) as SteganographyPayload;\n    return payload;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if an image has our watermark (quick check)\n */\nexport async function hasWatermark(imageBuffer: Buffer): Promise<boolean> {\n  const payload = await extractPayload(imageBuffer);\n  return payload !== null;\n}\n\n/**\n * Get the minimum image dimensions required for a payload\n */\nexport function getMinimumDimensions(payloadLength: number): number {\n  // Each pixel holds 2 bits, 8 bits per character\n  const bitsNeeded = payloadLength * 8;\n  const pixelsNeeded = Math.ceil(bitsNeeded / 2);\n  // Return minimum square dimension\n  return Math.ceil(Math.sqrt(pixelsNeeded));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 265, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/hash.ts"],"sourcesContent":["import { createHash } from \"crypto\";\nimport { Jimp } from \"jimp\";\n\n/**\n * Convert integer color to RGBA components\n */\nfunction intToRGBA(color: number): { r: number; g: number; b: number; a: number } {\n  return {\n    r: (color >> 24) & 0xff,\n    g: (color >> 16) & 0xff,\n    b: (color >> 8) & 0xff,\n    a: color & 0xff,\n  };\n}\n\n/**\n * Compute SHA-256 hash of image pixel data\n * This hashes the actual pixel values, not the file format\n * @param imageBuffer - The image buffer\n * @returns The full SHA-256 hash as hex string\n */\nexport async function hashImagePixels(imageBuffer: Buffer): Promise<string> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Create a buffer of all pixel values (RGBA)\n  const pixelData = Buffer.alloc(width * height * 4);\n  let offset = 0;\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      pixelData.writeUInt8(rgba.r, offset++);\n      pixelData.writeUInt8(rgba.g, offset++);\n      pixelData.writeUInt8(rgba.b, offset++);\n      pixelData.writeUInt8(rgba.a, offset++);\n    }\n  }\n\n  // Compute SHA-256 hash\n  const hash = createHash(\"sha256\");\n  hash.update(pixelData);\n  return hash.digest(\"hex\");\n}\n\n/**\n * Get the first 8 characters of the SHA-256 hash\n * This is what we embed in the steganographic payload\n */\nexport async function getShortHash(imageBuffer: Buffer): Promise<string> {\n  const fullHash = await hashImagePixels(imageBuffer);\n  return fullHash.substring(0, 8);\n}\n\n/**\n * Compute SHA-256 hash of a string\n */\nexport function hashString(str: string): string {\n  const hash = createHash(\"sha256\");\n  hash.update(str);\n  return hash.digest(\"hex\");\n}\n\n/**\n * Compare two image hashes to detect tampering\n * @param originalHash - The hash embedded in the image\n * @param currentHash - The hash of the current image (first 8 chars)\n * @returns true if hashes match, false if tampered\n */\nexport function compareHashes(\n  originalHash: string,\n  currentHash: string\n): boolean {\n  // Compare first 8 characters\n  return (\n    originalHash.substring(0, 8).toLowerCase() ===\n    currentHash.substring(0, 8).toLowerCase()\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAEA;;CAEC,GACD,SAAS,UAAU,KAAa;IAC9B,OAAO;QACL,GAAG,AAAC,SAAS,KAAM;QACnB,GAAG,AAAC,SAAS,KAAM;QACnB,GAAG,AAAC,SAAS,IAAK;QAClB,GAAG,QAAQ;IACb;AACF;AAQO,eAAe,gBAAgB,WAAmB;IACvD,MAAM,QAAQ,MAAM,sKAAI,CAAC,IAAI,CAAC;IAC9B,MAAM,QAAQ,MAAM,KAAK;IACzB,MAAM,SAAS,MAAM,MAAM;IAE3B,6CAA6C;IAC7C,MAAM,YAAY,OAAO,KAAK,CAAC,QAAQ,SAAS;IAChD,IAAI,SAAS;IAEb,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC9B,MAAM,aAAa,MAAM,aAAa,CAAC,GAAG;YAC1C,MAAM,OAAO,UAAU;YAEvB,UAAU,UAAU,CAAC,KAAK,CAAC,EAAE;YAC7B,UAAU,UAAU,CAAC,KAAK,CAAC,EAAE;YAC7B,UAAU,UAAU,CAAC,KAAK,CAAC,EAAE;YAC7B,UAAU,UAAU,CAAC,KAAK,CAAC,EAAE;QAC/B;IACF;IAEA,uBAAuB;IACvB,MAAM,OAAO,IAAA,mHAAU,EAAC;IACxB,KAAK,MAAM,CAAC;IACZ,OAAO,KAAK,MAAM,CAAC;AACrB;AAMO,eAAe,aAAa,WAAmB;IACpD,MAAM,WAAW,MAAM,gBAAgB;IACvC,OAAO,SAAS,SAAS,CAAC,GAAG;AAC/B;AAKO,SAAS,WAAW,GAAW;IACpC,MAAM,OAAO,IAAA,mHAAU,EAAC;IACxB,KAAK,MAAM,CAAC;IACZ,OAAO,KAAK,MAAM,CAAC;AACrB;AAQO,SAAS,cACd,YAAoB,EACpB,WAAmB;IAEnB,6BAA6B;IAC7B,OACE,aAAa,SAAS,CAAC,GAAG,GAAG,WAAW,OACxC,YAAY,SAAS,CAAC,GAAG,GAAG,WAAW;AAE3C"}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/db.ts"],"sourcesContent":["import Database from \"better-sqlite3\";\nimport path from \"path\";\n\n// Database file path\nconst DB_PATH = path.join(process.cwd(), \"reclaim.db\");\n\n// Create or open database\nconst db = new Database(DB_PATH);\n\n// Enable WAL mode for better performance\ndb.pragma(\"journal_mode = WAL\");\n\n// Initialize database schema\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS creators (\n    id TEXT PRIMARY KEY,\n    display_name TEXT,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  );\n\n  CREATE TABLE IF NOT EXISTS signed_images (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    creator_id TEXT NOT NULL,\n    original_hash TEXT NOT NULL,\n    signed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (creator_id) REFERENCES creators(id)\n  );\n\n  CREATE INDEX IF NOT EXISTS idx_signed_images_creator_id ON signed_images(creator_id);\n  CREATE INDEX IF NOT EXISTS idx_signed_images_hash ON signed_images(original_hash);\n`);\n\n// Migration: Add display_name column if it doesn't exist (for existing DBs)\ntry {\n  db.exec(`ALTER TABLE creators ADD COLUMN display_name TEXT`);\n} catch {\n  // Column already exists, ignore\n}\n\n// Prepared statements\nconst insertCreator = db.prepare(\n  \"INSERT OR IGNORE INTO creators (id, display_name) VALUES (?, ?)\"\n);\n\nconst updateCreatorDisplayName = db.prepare(\n  \"UPDATE creators SET display_name = ? WHERE id = ?\"\n);\n\nconst insertSignedImage = db.prepare(\n  \"INSERT INTO signed_images (creator_id, original_hash) VALUES (?, ?)\"\n);\n\nconst getCreator = db.prepare(\"SELECT * FROM creators WHERE id = ?\");\n\nconst getCreatorImages = db.prepare(\n  \"SELECT * FROM signed_images WHERE creator_id = ? ORDER BY signed_at DESC\"\n);\n\nconst getImageByHash = db.prepare(\n  \"SELECT si.*, c.created_at as creator_created_at FROM signed_images si JOIN creators c ON si.creator_id = c.id WHERE si.original_hash = ?\"\n);\n\nconst getCreatorImageCount = db.prepare(\n  \"SELECT COUNT(*) as count FROM signed_images WHERE creator_id = ?\"\n);\n\n// Export functions\nexport interface Creator {\n  id: string;\n  display_name: string | null;\n  created_at: string;\n}\n\nexport interface SignedImage {\n  id: number;\n  creator_id: string;\n  original_hash: string;\n  signed_at: string;\n}\n\nexport function createCreator(walletAddress: string, displayName?: string): void {\n  insertCreator.run(walletAddress, displayName || null);\n}\n\nexport function updateDisplayName(walletAddress: string, displayName: string): void {\n  updateCreatorDisplayName.run(displayName, walletAddress);\n}\n\nexport function creatorExists(walletAddress: string): boolean {\n  const creator = getCreator.get(walletAddress) as Creator | undefined;\n  return !!creator;\n}\n\nexport function recordSignedImage(\n  creatorId: string,\n  originalHash: string\n): number {\n  // Insert the signed image record (creator must exist)\n  const result = insertSignedImage.run(creatorId, originalHash);\n  return Number(result.lastInsertRowid);\n}\n\nexport function getCreatorById(creatorId: string): Creator | undefined {\n  return getCreator.get(creatorId) as Creator | undefined;\n}\n\nexport function getImagesByCreator(creatorId: string): SignedImage[] {\n  return getCreatorImages.all(creatorId) as SignedImage[];\n}\n\nexport function findImageByHash(\n  hash: string\n): (SignedImage & { creator_created_at: string }) | undefined {\n  return getImageByHash.get(hash) as\n    | (SignedImage & { creator_created_at: string })\n    | undefined;\n}\n\nexport function getCreatorStats(creatorId: string): { totalSigned: number } {\n  const result = getCreatorImageCount.get(creatorId) as { count: number };\n  return { totalSigned: result?.count ?? 0 };\n}\n\nexport { db };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,qBAAqB;AACrB,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAEzC,0BAA0B;AAC1B,MAAM,KAAK,IAAI,8LAAQ,CAAC;AAExB,yCAAyC;AACzC,GAAG,MAAM,CAAC;AAEV,6BAA6B;AAC7B,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;AAiBT,CAAC;AAED,4EAA4E;AAC5E,IAAI;IACF,GAAG,IAAI,CAAC,CAAC,iDAAiD,CAAC;AAC7D,EAAE,OAAM;AACN,gCAAgC;AAClC;AAEA,sBAAsB;AACtB,MAAM,gBAAgB,GAAG,OAAO,CAC9B;AAGF,MAAM,2BAA2B,GAAG,OAAO,CACzC;AAGF,MAAM,oBAAoB,GAAG,OAAO,CAClC;AAGF,MAAM,aAAa,GAAG,OAAO,CAAC;AAE9B,MAAM,mBAAmB,GAAG,OAAO,CACjC;AAGF,MAAM,iBAAiB,GAAG,OAAO,CAC/B;AAGF,MAAM,uBAAuB,GAAG,OAAO,CACrC;AAiBK,SAAS,cAAc,aAAqB,EAAE,WAAoB;IACvE,cAAc,GAAG,CAAC,eAAe,eAAe;AAClD;AAEO,SAAS,kBAAkB,aAAqB,EAAE,WAAmB;IAC1E,yBAAyB,GAAG,CAAC,aAAa;AAC5C;AAEO,SAAS,cAAc,aAAqB;IACjD,MAAM,UAAU,WAAW,GAAG,CAAC;IAC/B,OAAO,CAAC,CAAC;AACX;AAEO,SAAS,kBACd,SAAiB,EACjB,YAAoB;IAEpB,sDAAsD;IACtD,MAAM,SAAS,kBAAkB,GAAG,CAAC,WAAW;IAChD,OAAO,OAAO,OAAO,eAAe;AACtC;AAEO,SAAS,eAAe,SAAiB;IAC9C,OAAO,WAAW,GAAG,CAAC;AACxB;AAEO,SAAS,mBAAmB,SAAiB;IAClD,OAAO,iBAAiB,GAAG,CAAC;AAC9B;AAEO,SAAS,gBACd,IAAY;IAEZ,OAAO,eAAe,GAAG,CAAC;AAG5B;AAEO,SAAS,gBAAgB,SAAiB;IAC/C,MAAM,SAAS,qBAAqB,GAAG,CAAC;IACxC,OAAO;QAAE,aAAa,QAAQ,SAAS;IAAE;AAC3C"}},
    {"offset": {"line": 426, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/app/api/sign/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { embedPayload, SteganographyPayload } from \"@/lib/steganography\";\nimport { getShortHash } from \"@/lib/hash\";\nimport { recordSignedImage } from \"@/lib/db\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"image\") as File | null;\n    const creatorId = formData.get(\"creator_id\") as string | null;\n\n    // Validate inputs\n    if (!file) {\n      return NextResponse.json(\n        { success: false, error: \"No image file provided\" },\n        { status: 400 }\n      );\n    }\n\n    if (!creatorId || creatorId.trim() === \"\") {\n      return NextResponse.json(\n        { success: false, error: \"Creator ID is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Check file type\n    const allowedTypes = [\"image/png\", \"image/jpeg\", \"image/jpg\"];\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: \"Invalid file type. Only PNG and JPEG are supported.\",\n        },\n        { status: 400 }\n      );\n    }\n\n    // Convert file to buffer\n    const arrayBuffer = await file.arrayBuffer();\n    const imageBuffer = Buffer.from(arrayBuffer);\n\n    // Get short hash of original image\n    const originalHash = await getShortHash(imageBuffer);\n\n    // Create payload\n    const timestamp = Math.floor(Date.now() / 1000);\n    const payload: SteganographyPayload = {\n      v: 1,\n      c: creatorId.trim(),\n      t: timestamp,\n      h: originalHash,\n    };\n\n    // Embed payload into image\n    const signedImageBuffer = await embedPayload(imageBuffer, payload);\n\n    // Record in database\n    recordSignedImage(creatorId.trim(), originalHash);\n\n    // Convert to base64 for response\n    const signedImageBase64 = signedImageBuffer.toString(\"base64\");\n\n    return NextResponse.json({\n      success: true,\n      signedImageBase64,\n      metadata: {\n        creatorId: payload.c,\n        timestamp: new Date(payload.t * 1000).toISOString(),\n        originalHash: payload.h,\n        version: payload.v,\n      },\n    });\n  } catch (error) {\n    console.error(\"Sign error:\", error);\n    const message =\n      error instanceof Error ? error.message : \"Failed to sign image\";\n    return NextResponse.json({ success: false, error: message }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAC1B,MAAM,YAAY,SAAS,GAAG,CAAC;QAE/B,kBAAkB;QAClB,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAyB,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,aAAa,UAAU,IAAI,OAAO,IAAI;YACzC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAyB,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,eAAe;YAAC;YAAa;YAAc;SAAY;QAC7D,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;YACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,SAAS;gBACT,OAAO;YACT,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,cAAc,OAAO,IAAI,CAAC;QAEhC,mCAAmC;QACnC,MAAM,eAAe,MAAM,IAAA,6HAAY,EAAC;QAExC,iBAAiB;QACjB,MAAM,YAAY,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK;QAC1C,MAAM,UAAgC;YACpC,GAAG;YACH,GAAG,UAAU,IAAI;YACjB,GAAG;YACH,GAAG;QACL;QAEA,2BAA2B;QAC3B,MAAM,oBAAoB,MAAM,IAAA,sIAAY,EAAC,aAAa;QAE1D,qBAAqB;QACrB,IAAA,gIAAiB,EAAC,UAAU,IAAI,IAAI;QAEpC,iCAAiC;QACjC,MAAM,oBAAoB,kBAAkB,QAAQ,CAAC;QAErD,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,UAAU;gBACR,WAAW,QAAQ,CAAC;gBACpB,WAAW,IAAI,KAAK,QAAQ,CAAC,GAAG,MAAM,WAAW;gBACjD,cAAc,QAAQ,CAAC;gBACvB,SAAS,QAAQ,CAAC;YACpB;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,eAAe;QAC7B,MAAM,UACJ,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAO,OAAO;QAAQ,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF"}}]
}