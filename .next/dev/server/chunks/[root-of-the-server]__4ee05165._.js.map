{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/steganography.ts"],"sourcesContent":["import { Jimp } from \"jimp\";\n\n// Magic header to identify our watermarked images\nconst MAGIC_HEADER = \"RECLAIM_V1:\";\n\n// End marker to know where the message ends\nconst END_MARKER = \":END_RECLAIM\";\n\nexport interface SteganographyPayload {\n  v: number; // version\n  c: string; // creator_id\n  t: number; // timestamp\n  h: string; // first 8 chars of SHA-256 of original image\n}\n\n/**\n * Convert a string to binary representation\n */\nfunction stringToBinary(str: string): string {\n  return str\n    .split(\"\")\n    .map((char) => char.charCodeAt(0).toString(2).padStart(8, \"0\"))\n    .join(\"\");\n}\n\n/**\n * Convert binary representation back to string\n */\nfunction binaryToString(binary: string): string {\n  const bytes = binary.match(/.{8}/g);\n  if (!bytes) return \"\";\n  return bytes.map((byte) => String.fromCharCode(parseInt(byte, 2))).join(\"\");\n}\n\n/**\n * Convert integer color to RGBA components\n */\nfunction intToRGBA(color: number): { r: number; g: number; b: number; a: number } {\n  return {\n    r: (color >> 24) & 0xff,\n    g: (color >> 16) & 0xff,\n    b: (color >> 8) & 0xff,\n    a: color & 0xff,\n  };\n}\n\n/**\n * Convert RGBA components to integer color\n */\nfunction rgbaToInt(r: number, g: number, b: number, a: number): number {\n  return ((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (a & 0xff);\n}\n\n/**\n * Calculate the maximum message length that can be embedded in an image\n * We use 2 bits per pixel (from the blue and green channels) for better capacity\n */\nfunction getMaxMessageLength(width: number, height: number): number {\n  // Each pixel can hold 2 bits (blue and green LSB)\n  // 8 bits per character\n  const totalBits = width * height * 2;\n  return Math.floor(totalBits / 8);\n}\n\n/**\n * Embed a payload into an image using LSB steganography\n * @param imageBuffer - The original image buffer\n * @param payload - The payload to embed\n * @returns The watermarked image as a PNG buffer\n */\nexport async function embedPayload(\n  imageBuffer: Buffer,\n  payload: SteganographyPayload\n): Promise<Buffer> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Create the full message with magic header and end marker\n  const payloadJson = JSON.stringify(payload);\n  const fullMessage = MAGIC_HEADER + payloadJson + END_MARKER;\n\n  // Check if the message fits\n  const maxLength = getMaxMessageLength(width, height);\n  if (fullMessage.length > maxLength) {\n    throw new Error(\n      `Message too long for image. Max: ${maxLength} chars, Message: ${fullMessage.length} chars`\n    );\n  }\n\n  // Convert message to binary\n  const binaryMessage = stringToBinary(fullMessage);\n\n  // Embed the binary message into the image\n  let bitIndex = 0;\n\n  for (let y = 0; y < height && bitIndex < binaryMessage.length; y++) {\n    for (let x = 0; x < width && bitIndex < binaryMessage.length; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Embed in blue channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.b = (rgba.b & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Embed in green channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.g = (rgba.g & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Set the modified pixel\n      const newColor = rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a);\n      image.setPixelColor(newColor, x, y);\n    }\n  }\n\n  // Return as PNG buffer (PNG is lossless, important for LSB)\n  return await image.getBuffer(\"image/png\");\n}\n\n/**\n * Extract a payload from an image\n * @param imageBuffer - The image buffer to extract from\n * @returns The extracted payload, or null if not found\n */\nexport async function extractPayload(\n  imageBuffer: Buffer\n): Promise<SteganographyPayload | null> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Extract bits from the image\n  let binaryString = \"\";\n  const maxBits = width * height * 2;\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Extract from blue channel LSB\n      binaryString += (rgba.b & 1).toString();\n\n      // Extract from green channel LSB\n      binaryString += (rgba.g & 1).toString();\n\n      // Check periodically for the end marker to avoid processing entire image\n      if (binaryString.length % 800 === 0 && binaryString.length > 0) {\n        const partialMessage = binaryToString(binaryString);\n        if (partialMessage.includes(END_MARKER)) {\n          break;\n        }\n      }\n\n      // Safety limit\n      if (binaryString.length > maxBits) break;\n    }\n\n    // Check if we've found the end marker\n    const partialMessage = binaryToString(binaryString);\n    if (partialMessage.includes(END_MARKER)) {\n      break;\n    }\n  }\n\n  // Convert binary to string\n  const extractedMessage = binaryToString(binaryString);\n\n  // Check for magic header\n  if (!extractedMessage.startsWith(MAGIC_HEADER)) {\n    return null;\n  }\n\n  // Find the end marker\n  const endIndex = extractedMessage.indexOf(END_MARKER);\n  if (endIndex === -1) {\n    return null;\n  }\n\n  // Extract the JSON payload\n  const jsonStart = MAGIC_HEADER.length;\n  const jsonString = extractedMessage.substring(jsonStart, endIndex);\n\n  try {\n    const payload = JSON.parse(jsonString) as SteganographyPayload;\n    return payload;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if an image has our watermark (quick check)\n */\nexport async function hasWatermark(imageBuffer: Buffer): Promise<boolean> {\n  const payload = await extractPayload(imageBuffer);\n  return payload !== null;\n}\n\n/**\n * Get the minimum image dimensions required for a payload\n */\nexport function getMinimumDimensions(payloadLength: number): number {\n  // Each pixel holds 2 bits, 8 bits per character\n  const bitsNeeded = payloadLength * 8;\n  const pixelsNeeded = Math.ceil(bitsNeeded / 2);\n  // Return minimum square dimension\n  return Math.ceil(Math.sqrt(pixelsNeeded));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/app/api/verify/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { extractPayload } from \"@/lib/steganography\";\n\nexport interface VerifyResponse {\n  verified: boolean;\n  creator?: string;\n  timestamp?: string;\n  tampered?: boolean;\n  message: string;\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"image\") as File | null;\n\n    // Validate inputs\n    if (!file) {\n      return NextResponse.json(\n        { verified: false, message: \"No image file provided\" },\n        { status: 400 }\n      );\n    }\n\n    // Check file type\n    const allowedTypes = [\"image/png\", \"image/jpeg\", \"image/jpg\"];\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        {\n          verified: false,\n          message: \"Invalid file type. Only PNG and JPEG are supported.\",\n        },\n        { status: 400 }\n      );\n    }\n\n    // Convert file to buffer\n    const arrayBuffer = await file.arrayBuffer();\n    const imageBuffer = Buffer.from(arrayBuffer);\n\n    // Try to extract payload\n    const payload = await extractPayload(imageBuffer);\n\n    if (!payload) {\n      return NextResponse.json({\n        verified: false,\n        message: \"No signature found - origin unknown\",\n      } as VerifyResponse);\n    }\n\n    // Payload found - check for tampering\n    // Note: We compute hash of the current image and compare with embedded hash\n    // However, the watermark itself changes the image, so we can't directly compare\n    // For MVP, we'll skip the tampering check as it requires the original image\n    // In a real implementation, you'd use perceptual hashing or store the original separately\n\n    const response: VerifyResponse = {\n      verified: true,\n      creator: payload.c,\n      timestamp: new Date(payload.t * 1000).toISOString(),\n      tampered: false, // MVP: assume not tampered if signature found\n      message: `Verified - Signed by ${payload.c}`,\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    console.error(\"Verify error:\", error);\n    return NextResponse.json(\n      { verified: false, message: \"Failed to verify image\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAUO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,kBAAkB;QAClB,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,UAAU;gBAAO,SAAS;YAAyB,GACrD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,eAAe;YAAC;YAAa;YAAc;SAAY;QAC7D,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;YACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,UAAU;gBACV,SAAS;YACX,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,cAAc,OAAO,IAAI,CAAC;QAEhC,yBAAyB;QACzB,MAAM,UAAU,MAAM,IAAA,wIAAc,EAAC;QAErC,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,UAAU;gBACV,SAAS;YACX;QACF;QAEA,sCAAsC;QACtC,4EAA4E;QAC5E,gFAAgF;QAChF,4EAA4E;QAC5E,0FAA0F;QAE1F,MAAM,WAA2B;YAC/B,UAAU;YACV,SAAS,QAAQ,CAAC;YAClB,WAAW,IAAI,KAAK,QAAQ,CAAC,GAAG,MAAM,WAAW;YACjD,UAAU;YACV,SAAS,CAAC,qBAAqB,EAAE,QAAQ,CAAC,EAAE;QAC9C;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,UAAU;YAAO,SAAS;QAAyB,GACrD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}