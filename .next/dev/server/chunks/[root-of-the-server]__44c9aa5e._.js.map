{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/steganography.ts"],"sourcesContent":["import { Jimp } from \"jimp\";\n\n// Magic header to identify our watermarked images\nconst MAGIC_HEADER = \"RECLAIM_V1:\";\n\n// End marker to know where the message ends\nconst END_MARKER = \":END_RECLAIM\";\n\nexport interface SteganographyPayload {\n  v: number; // version\n  c: string; // creator_id\n  t: number; // timestamp\n  h: string; // first 8 chars of SHA-256 of original image\n}\n\n/**\n * Convert a string to binary representation\n */\nfunction stringToBinary(str: string): string {\n  return str\n    .split(\"\")\n    .map((char) => char.charCodeAt(0).toString(2).padStart(8, \"0\"))\n    .join(\"\");\n}\n\n/**\n * Convert binary representation back to string\n */\nfunction binaryToString(binary: string): string {\n  const bytes = binary.match(/.{8}/g);\n  if (!bytes) return \"\";\n  return bytes.map((byte) => String.fromCharCode(parseInt(byte, 2))).join(\"\");\n}\n\n/**\n * Convert integer color to RGBA components\n */\nfunction intToRGBA(color: number): { r: number; g: number; b: number; a: number } {\n  return {\n    r: (color >> 24) & 0xff,\n    g: (color >> 16) & 0xff,\n    b: (color >> 8) & 0xff,\n    a: color & 0xff,\n  };\n}\n\n/**\n * Convert RGBA components to integer color\n */\nfunction rgbaToInt(r: number, g: number, b: number, a: number): number {\n  return ((r & 0xff) << 24) | ((g & 0xff) << 16) | ((b & 0xff) << 8) | (a & 0xff);\n}\n\n/**\n * Calculate the maximum message length that can be embedded in an image\n * We use 2 bits per pixel (from the blue and green channels) for better capacity\n */\nfunction getMaxMessageLength(width: number, height: number): number {\n  // Each pixel can hold 2 bits (blue and green LSB)\n  // 8 bits per character\n  const totalBits = width * height * 2;\n  return Math.floor(totalBits / 8);\n}\n\n/**\n * Embed a payload into an image using LSB steganography\n * @param imageBuffer - The original image buffer\n * @param payload - The payload to embed\n * @returns The watermarked image as a PNG buffer\n */\nexport async function embedPayload(\n  imageBuffer: Buffer,\n  payload: SteganographyPayload\n): Promise<Buffer> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Create the full message with magic header and end marker\n  const payloadJson = JSON.stringify(payload);\n  const fullMessage = MAGIC_HEADER + payloadJson + END_MARKER;\n\n  // Check if the message fits\n  const maxLength = getMaxMessageLength(width, height);\n  if (fullMessage.length > maxLength) {\n    throw new Error(\n      `Message too long for image. Max: ${maxLength} chars, Message: ${fullMessage.length} chars`\n    );\n  }\n\n  // Convert message to binary\n  const binaryMessage = stringToBinary(fullMessage);\n\n  // Embed the binary message into the image\n  let bitIndex = 0;\n\n  for (let y = 0; y < height && bitIndex < binaryMessage.length; y++) {\n    for (let x = 0; x < width && bitIndex < binaryMessage.length; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Embed in blue channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.b = (rgba.b & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Embed in green channel LSB\n      if (bitIndex < binaryMessage.length) {\n        const bit = parseInt(binaryMessage[bitIndex], 10);\n        rgba.g = (rgba.g & 0xfe) | bit;\n        bitIndex++;\n      }\n\n      // Set the modified pixel\n      const newColor = rgbaToInt(rgba.r, rgba.g, rgba.b, rgba.a);\n      image.setPixelColor(newColor, x, y);\n    }\n  }\n\n  // Return as PNG buffer (PNG is lossless, important for LSB)\n  return await image.getBuffer(\"image/png\");\n}\n\n/**\n * Extract a payload from an image\n * @param imageBuffer - The image buffer to extract from\n * @returns The extracted payload, or null if not found\n */\nexport async function extractPayload(\n  imageBuffer: Buffer\n): Promise<SteganographyPayload | null> {\n  const image = await Jimp.read(imageBuffer);\n  const width = image.width;\n  const height = image.height;\n\n  // Extract bits from the image\n  let binaryString = \"\";\n  const maxBits = width * height * 2;\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const pixelColor = image.getPixelColor(x, y);\n      const rgba = intToRGBA(pixelColor);\n\n      // Extract from blue channel LSB\n      binaryString += (rgba.b & 1).toString();\n\n      // Extract from green channel LSB\n      binaryString += (rgba.g & 1).toString();\n\n      // Check periodically for the end marker to avoid processing entire image\n      if (binaryString.length % 800 === 0 && binaryString.length > 0) {\n        const partialMessage = binaryToString(binaryString);\n        if (partialMessage.includes(END_MARKER)) {\n          break;\n        }\n      }\n\n      // Safety limit\n      if (binaryString.length > maxBits) break;\n    }\n\n    // Check if we've found the end marker\n    const partialMessage = binaryToString(binaryString);\n    if (partialMessage.includes(END_MARKER)) {\n      break;\n    }\n  }\n\n  // Convert binary to string\n  const extractedMessage = binaryToString(binaryString);\n\n  // Check for magic header\n  if (!extractedMessage.startsWith(MAGIC_HEADER)) {\n    return null;\n  }\n\n  // Find the end marker\n  const endIndex = extractedMessage.indexOf(END_MARKER);\n  if (endIndex === -1) {\n    return null;\n  }\n\n  // Extract the JSON payload\n  const jsonStart = MAGIC_HEADER.length;\n  const jsonString = extractedMessage.substring(jsonStart, endIndex);\n\n  try {\n    const payload = JSON.parse(jsonString) as SteganographyPayload;\n    return payload;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if an image has our watermark (quick check)\n */\nexport async function hasWatermark(imageBuffer: Buffer): Promise<boolean> {\n  const payload = await extractPayload(imageBuffer);\n  return payload !== null;\n}\n\n/**\n * Get the minimum image dimensions required for a payload\n */\nexport function getMinimumDimensions(payloadLength: number): number {\n  // Each pixel holds 2 bits, 8 bits per character\n  const bitsNeeded = payloadLength * 8;\n  const pixelsNeeded = Math.ceil(bitsNeeded / 2);\n  // Return minimum square dimension\n  return Math.ceil(Math.sqrt(pixelsNeeded));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 259, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/db.ts"],"sourcesContent":["import Database from \"better-sqlite3\";\nimport path from \"path\";\n\n// Database file path\nconst DB_PATH = path.join(process.cwd(), \"reclaim.db\");\n\n// Create or open database\nconst db = new Database(DB_PATH);\n\n// Enable WAL mode for better performance\ndb.pragma(\"journal_mode = WAL\");\n\n// Initialize database schema\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS creators (\n    id TEXT PRIMARY KEY,\n    display_name TEXT,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  );\n\n  CREATE TABLE IF NOT EXISTS signed_images (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    creator_id TEXT NOT NULL,\n    original_hash TEXT NOT NULL,\n    signed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (creator_id) REFERENCES creators(id)\n  );\n\n  CREATE INDEX IF NOT EXISTS idx_signed_images_creator_id ON signed_images(creator_id);\n  CREATE INDEX IF NOT EXISTS idx_signed_images_hash ON signed_images(original_hash);\n`);\n\n// Migration: Add display_name column if it doesn't exist (for existing DBs)\ntry {\n  db.exec(`ALTER TABLE creators ADD COLUMN display_name TEXT`);\n} catch {\n  // Column already exists, ignore\n}\n\n// Prepared statements\nconst insertCreator = db.prepare(\n  \"INSERT OR IGNORE INTO creators (id, display_name) VALUES (?, ?)\"\n);\n\nconst updateCreatorDisplayName = db.prepare(\n  \"UPDATE creators SET display_name = ? WHERE id = ?\"\n);\n\nconst insertSignedImage = db.prepare(\n  \"INSERT INTO signed_images (creator_id, original_hash) VALUES (?, ?)\"\n);\n\nconst getCreator = db.prepare(\"SELECT * FROM creators WHERE id = ?\");\n\nconst getCreatorImages = db.prepare(\n  \"SELECT * FROM signed_images WHERE creator_id = ? ORDER BY signed_at DESC\"\n);\n\nconst getImageByHash = db.prepare(\n  \"SELECT si.*, c.created_at as creator_created_at FROM signed_images si JOIN creators c ON si.creator_id = c.id WHERE si.original_hash = ?\"\n);\n\nconst getCreatorImageCount = db.prepare(\n  \"SELECT COUNT(*) as count FROM signed_images WHERE creator_id = ?\"\n);\n\n// Export functions\nexport interface Creator {\n  id: string;\n  display_name: string | null;\n  created_at: string;\n}\n\nexport interface SignedImage {\n  id: number;\n  creator_id: string;\n  original_hash: string;\n  signed_at: string;\n}\n\nexport function createCreator(walletAddress: string, displayName?: string): void {\n  insertCreator.run(walletAddress, displayName || null);\n}\n\nexport function updateDisplayName(walletAddress: string, displayName: string): void {\n  updateCreatorDisplayName.run(displayName, walletAddress);\n}\n\nexport function creatorExists(walletAddress: string): boolean {\n  const creator = getCreator.get(walletAddress) as Creator | undefined;\n  return !!creator;\n}\n\nexport function recordSignedImage(\n  creatorId: string,\n  originalHash: string\n): number {\n  // Insert the signed image record (creator must exist)\n  const result = insertSignedImage.run(creatorId, originalHash);\n  return Number(result.lastInsertRowid);\n}\n\nexport function getCreatorById(creatorId: string): Creator | undefined {\n  return getCreator.get(creatorId) as Creator | undefined;\n}\n\nexport function getImagesByCreator(creatorId: string): SignedImage[] {\n  return getCreatorImages.all(creatorId) as SignedImage[];\n}\n\nexport function findImageByHash(\n  hash: string\n): (SignedImage & { creator_created_at: string }) | undefined {\n  return getImageByHash.get(hash) as\n    | (SignedImage & { creator_created_at: string })\n    | undefined;\n}\n\nexport function getCreatorStats(creatorId: string): { totalSigned: number } {\n  const result = getCreatorImageCount.get(creatorId) as { count: number };\n  return { totalSigned: result?.count ?? 0 };\n}\n\nexport { db };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,qBAAqB;AACrB,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAEzC,0BAA0B;AAC1B,MAAM,KAAK,IAAI,8LAAQ,CAAC;AAExB,yCAAyC;AACzC,GAAG,MAAM,CAAC;AAEV,6BAA6B;AAC7B,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;AAiBT,CAAC;AAED,4EAA4E;AAC5E,IAAI;IACF,GAAG,IAAI,CAAC,CAAC,iDAAiD,CAAC;AAC7D,EAAE,OAAM;AACN,gCAAgC;AAClC;AAEA,sBAAsB;AACtB,MAAM,gBAAgB,GAAG,OAAO,CAC9B;AAGF,MAAM,2BAA2B,GAAG,OAAO,CACzC;AAGF,MAAM,oBAAoB,GAAG,OAAO,CAClC;AAGF,MAAM,aAAa,GAAG,OAAO,CAAC;AAE9B,MAAM,mBAAmB,GAAG,OAAO,CACjC;AAGF,MAAM,iBAAiB,GAAG,OAAO,CAC/B;AAGF,MAAM,uBAAuB,GAAG,OAAO,CACrC;AAiBK,SAAS,cAAc,aAAqB,EAAE,WAAoB;IACvE,cAAc,GAAG,CAAC,eAAe,eAAe;AAClD;AAEO,SAAS,kBAAkB,aAAqB,EAAE,WAAmB;IAC1E,yBAAyB,GAAG,CAAC,aAAa;AAC5C;AAEO,SAAS,cAAc,aAAqB;IACjD,MAAM,UAAU,WAAW,GAAG,CAAC;IAC/B,OAAO,CAAC,CAAC;AACX;AAEO,SAAS,kBACd,SAAiB,EACjB,YAAoB;IAEpB,sDAAsD;IACtD,MAAM,SAAS,kBAAkB,GAAG,CAAC,WAAW;IAChD,OAAO,OAAO,OAAO,eAAe;AACtC;AAEO,SAAS,eAAe,SAAiB;IAC9C,OAAO,WAAW,GAAG,CAAC;AACxB;AAEO,SAAS,mBAAmB,SAAiB;IAClD,OAAO,iBAAiB,GAAG,CAAC;AAC9B;AAEO,SAAS,gBACd,IAAY;IAEZ,OAAO,eAAe,GAAG,CAAC;AAG5B;AAEO,SAAS,gBAAgB,SAAiB;IAC/C,MAAM,SAAS,qBAAqB,GAAG,CAAC;IACxC,OAAO;QAAE,aAAa,QAAQ,SAAS;IAAE;AAC3C"}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/app/api/verify/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { extractPayload } from \"@/lib/steganography\";\nimport { getCreatorById } from \"@/lib/db\";\n\nexport interface VerifyResponse {\n  verified: boolean;\n  creator?: string;\n  creatorDisplayName?: string;\n  timestamp?: string;\n  tampered?: boolean;\n  message: string;\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const formData = await request.formData();\n    const file = formData.get(\"image\") as File | null;\n\n    // Validate inputs\n    if (!file) {\n      return NextResponse.json(\n        { verified: false, message: \"No image file provided\" },\n        { status: 400 }\n      );\n    }\n\n    // Check file type\n    const allowedTypes = [\"image/png\", \"image/jpeg\", \"image/jpg\"];\n    if (!allowedTypes.includes(file.type)) {\n      return NextResponse.json(\n        {\n          verified: false,\n          message: \"Invalid file type. Only PNG and JPEG are supported.\",\n        },\n        { status: 400 }\n      );\n    }\n\n    // Convert file to buffer\n    const arrayBuffer = await file.arrayBuffer();\n    const imageBuffer = Buffer.from(arrayBuffer);\n\n    // Try to extract payload\n    const payload = await extractPayload(imageBuffer);\n\n    if (!payload) {\n      return NextResponse.json({\n        verified: false,\n        message: \"No signature found - origin unknown\",\n      } as VerifyResponse);\n    }\n\n    // Payload found - check for tampering\n    // Note: We compute hash of the current image and compare with embedded hash\n    // However, the watermark itself changes the image, so we can't directly compare\n    // For MVP, we'll skip the tampering check as it requires the original image\n    // In a real implementation, you'd use perceptual hashing or store the original separately\n\n    // Get creator display name from database\n    const creatorData = getCreatorById(payload.c);\n    const displayName = creatorData?.display_name || payload.c;\n\n    const response: VerifyResponse = {\n      verified: true,\n      creator: payload.c,\n      creatorDisplayName: displayName,\n      timestamp: new Date(payload.t * 1000).toISOString(),\n      tampered: false, // MVP: assume not tampered if signature found\n      message: `Verified - Signed by ${displayName}`,\n    };\n\n    return NextResponse.json(response);\n  } catch (error) {\n    console.error(\"Verify error:\", error);\n    return NextResponse.json(\n      { verified: false, message: \"Failed to verify image\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAWO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,WAAW,MAAM,QAAQ,QAAQ;QACvC,MAAM,OAAO,SAAS,GAAG,CAAC;QAE1B,kBAAkB;QAClB,IAAI,CAAC,MAAM;YACT,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,UAAU;gBAAO,SAAS;YAAyB,GACrD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,eAAe;YAAC;YAAa;YAAc;SAAY;QAC7D,IAAI,CAAC,aAAa,QAAQ,CAAC,KAAK,IAAI,GAAG;YACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,UAAU;gBACV,SAAS;YACX,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,cAAc,MAAM,KAAK,WAAW;QAC1C,MAAM,cAAc,OAAO,IAAI,CAAC;QAEhC,yBAAyB;QACzB,MAAM,UAAU,MAAM,IAAA,wIAAc,EAAC;QAErC,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,UAAU;gBACV,SAAS;YACX;QACF;QAEA,sCAAsC;QACtC,4EAA4E;QAC5E,gFAAgF;QAChF,4EAA4E;QAC5E,0FAA0F;QAE1F,yCAAyC;QACzC,MAAM,cAAc,IAAA,6HAAc,EAAC,QAAQ,CAAC;QAC5C,MAAM,cAAc,aAAa,gBAAgB,QAAQ,CAAC;QAE1D,MAAM,WAA2B;YAC/B,UAAU;YACV,SAAS,QAAQ,CAAC;YAClB,oBAAoB;YACpB,WAAW,IAAI,KAAK,QAAQ,CAAC,GAAG,MAAM,WAAW;YACjD,UAAU;YACV,SAAS,CAAC,qBAAqB,EAAE,aAAa;QAChD;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,UAAU;YAAO,SAAS;QAAyB,GACrD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}