{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/lib/db.ts"],"sourcesContent":["import Database from \"better-sqlite3\";\nimport path from \"path\";\n\n// Database file path\nconst DB_PATH = path.join(process.cwd(), \"reclaim.db\");\n\n// Create or open database\nconst db = new Database(DB_PATH);\n\n// Enable WAL mode for better performance\ndb.pragma(\"journal_mode = WAL\");\n\n// Initialize database schema\ndb.exec(`\n  CREATE TABLE IF NOT EXISTS creators (\n    id TEXT PRIMARY KEY,\n    display_name TEXT,\n    created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n  );\n\n  CREATE TABLE IF NOT EXISTS signed_images (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    creator_id TEXT NOT NULL,\n    original_hash TEXT NOT NULL,\n    signed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n    FOREIGN KEY (creator_id) REFERENCES creators(id)\n  );\n\n  CREATE INDEX IF NOT EXISTS idx_signed_images_creator_id ON signed_images(creator_id);\n  CREATE INDEX IF NOT EXISTS idx_signed_images_hash ON signed_images(original_hash);\n`);\n\n// Migration: Add display_name column if it doesn't exist (for existing DBs)\ntry {\n  db.exec(`ALTER TABLE creators ADD COLUMN display_name TEXT`);\n} catch {\n  // Column already exists, ignore\n}\n\n// Prepared statements\nconst insertCreator = db.prepare(\n  \"INSERT OR IGNORE INTO creators (id, display_name) VALUES (?, ?)\"\n);\n\nconst updateCreatorDisplayName = db.prepare(\n  \"UPDATE creators SET display_name = ? WHERE id = ?\"\n);\n\nconst insertSignedImage = db.prepare(\n  \"INSERT INTO signed_images (creator_id, original_hash) VALUES (?, ?)\"\n);\n\nconst getCreator = db.prepare(\"SELECT * FROM creators WHERE id = ?\");\n\nconst getCreatorImages = db.prepare(\n  \"SELECT * FROM signed_images WHERE creator_id = ? ORDER BY signed_at DESC\"\n);\n\nconst getImageByHash = db.prepare(\n  \"SELECT si.*, c.created_at as creator_created_at FROM signed_images si JOIN creators c ON si.creator_id = c.id WHERE si.original_hash = ?\"\n);\n\nconst getCreatorImageCount = db.prepare(\n  \"SELECT COUNT(*) as count FROM signed_images WHERE creator_id = ?\"\n);\n\n// Export functions\nexport interface Creator {\n  id: string;\n  display_name: string | null;\n  created_at: string;\n}\n\nexport interface SignedImage {\n  id: number;\n  creator_id: string;\n  original_hash: string;\n  signed_at: string;\n}\n\nexport function createCreator(walletAddress: string, displayName?: string): void {\n  insertCreator.run(walletAddress, displayName || null);\n}\n\nexport function updateDisplayName(walletAddress: string, displayName: string): void {\n  updateCreatorDisplayName.run(displayName, walletAddress);\n}\n\nexport function creatorExists(walletAddress: string): boolean {\n  const creator = getCreator.get(walletAddress) as Creator | undefined;\n  return !!creator;\n}\n\nexport function recordSignedImage(\n  creatorId: string,\n  originalHash: string\n): number {\n  // Insert the signed image record (creator must exist)\n  const result = insertSignedImage.run(creatorId, originalHash);\n  return Number(result.lastInsertRowid);\n}\n\nexport function getCreatorById(creatorId: string): Creator | undefined {\n  return getCreator.get(creatorId) as Creator | undefined;\n}\n\nexport function getImagesByCreator(creatorId: string): SignedImage[] {\n  return getCreatorImages.all(creatorId) as SignedImage[];\n}\n\nexport function findImageByHash(\n  hash: string\n): (SignedImage & { creator_created_at: string }) | undefined {\n  return getImageByHash.get(hash) as\n    | (SignedImage & { creator_created_at: string })\n    | undefined;\n}\n\nexport function getCreatorStats(creatorId: string): { totalSigned: number } {\n  const result = getCreatorImageCount.get(creatorId) as { count: number };\n  return { totalSigned: result?.count ?? 0 };\n}\n\nexport { db };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,qBAAqB;AACrB,MAAM,UAAU,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAEzC,0BAA0B;AAC1B,MAAM,KAAK,IAAI,8LAAQ,CAAC;AAExB,yCAAyC;AACzC,GAAG,MAAM,CAAC;AAEV,6BAA6B;AAC7B,GAAG,IAAI,CAAC,CAAC;;;;;;;;;;;;;;;;;AAiBT,CAAC;AAED,4EAA4E;AAC5E,IAAI;IACF,GAAG,IAAI,CAAC,CAAC,iDAAiD,CAAC;AAC7D,EAAE,OAAM;AACN,gCAAgC;AAClC;AAEA,sBAAsB;AACtB,MAAM,gBAAgB,GAAG,OAAO,CAC9B;AAGF,MAAM,2BAA2B,GAAG,OAAO,CACzC;AAGF,MAAM,oBAAoB,GAAG,OAAO,CAClC;AAGF,MAAM,aAAa,GAAG,OAAO,CAAC;AAE9B,MAAM,mBAAmB,GAAG,OAAO,CACjC;AAGF,MAAM,iBAAiB,GAAG,OAAO,CAC/B;AAGF,MAAM,uBAAuB,GAAG,OAAO,CACrC;AAiBK,SAAS,cAAc,aAAqB,EAAE,WAAoB;IACvE,cAAc,GAAG,CAAC,eAAe,eAAe;AAClD;AAEO,SAAS,kBAAkB,aAAqB,EAAE,WAAmB;IAC1E,yBAAyB,GAAG,CAAC,aAAa;AAC5C;AAEO,SAAS,cAAc,aAAqB;IACjD,MAAM,UAAU,WAAW,GAAG,CAAC;IAC/B,OAAO,CAAC,CAAC;AACX;AAEO,SAAS,kBACd,SAAiB,EACjB,YAAoB;IAEpB,sDAAsD;IACtD,MAAM,SAAS,kBAAkB,GAAG,CAAC,WAAW;IAChD,OAAO,OAAO,OAAO,eAAe;AACtC;AAEO,SAAS,eAAe,SAAiB;IAC9C,OAAO,WAAW,GAAG,CAAC;AACxB;AAEO,SAAS,mBAAmB,SAAiB;IAClD,OAAO,iBAAiB,GAAG,CAAC;AAC9B;AAEO,SAAS,gBACd,IAAY;IAEZ,OAAO,eAAe,GAAG,CAAC;AAG5B;AAEO,SAAS,gBAAgB,SAAiB;IAC/C,MAAM,SAAS,qBAAqB,GAAG,CAAC;IACxC,OAAO;QAAE,aAAa,QAAQ,SAAS;IAAE;AAC3C"}},
    {"offset": {"line": 150, "column": 0}, "map": {"version":3,"sources":["file:///Users/adyanullah/Documents/GitHub/reclaim-mchacks/app/api/auth/signup/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { createCreator, getCreatorById, creatorExists } from \"@/lib/db\";\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { wallet_address, display_name } = body;\n\n    if (!wallet_address) {\n      return NextResponse.json(\n        { error: \"Wallet address required\" },\n        { status: 400 }\n      );\n    }\n\n    if (!display_name || display_name.trim().length === 0) {\n      return NextResponse.json(\n        { error: \"Display name required\" },\n        { status: 400 }\n      );\n    }\n\n    if (display_name.length > 50) {\n      return NextResponse.json(\n        { error: \"Display name must be 50 characters or less\" },\n        { status: 400 }\n      );\n    }\n\n    // Check if creator already exists\n    if (creatorExists(wallet_address)) {\n      return NextResponse.json(\n        { error: \"Account already exists for this wallet\" },\n        { status: 409 }\n      );\n    }\n\n    // Create the creator\n    createCreator(wallet_address, display_name.trim());\n\n    // Fetch and return the created creator\n    const creator = getCreatorById(wallet_address);\n\n    return NextResponse.json({\n      success: true,\n      creator: {\n        id: creator!.id,\n        display_name: creator!.display_name,\n        created_at: creator!.created_at,\n      },\n    });\n  } catch (error) {\n    console.error(\"Signup error:\", error);\n    return NextResponse.json(\n      { error: \"Failed to create account\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,cAAc,EAAE,YAAY,EAAE,GAAG;QAEzC,IAAI,CAAC,gBAAgB;YACnB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0B,GACnC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,CAAC,gBAAgB,aAAa,IAAI,GAAG,MAAM,KAAK,GAAG;YACrD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,IAAI,aAAa,MAAM,GAAG,IAAI;YAC5B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA6C,GACtD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kCAAkC;QAClC,IAAI,IAAA,4HAAa,EAAC,iBAAiB;YACjC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAyC,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,IAAA,4HAAa,EAAC,gBAAgB,aAAa,IAAI;QAE/C,uCAAuC;QACvC,MAAM,UAAU,IAAA,6HAAc,EAAC;QAE/B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;gBACP,IAAI,QAAS,EAAE;gBACf,cAAc,QAAS,YAAY;gBACnC,YAAY,QAAS,UAAU;YACjC;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iBAAiB;QAC/B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}